package main

import (
    "fmt"
    "github.com/LanceLRQ/deer-common/sandbox/forkexec"
    "os"
    "syscall"
    "time"
)

//
//import (
//    "C"
//    "syscall"
//    "unsafe"
//    _ "unsafe"
//)
//
//// errnoErr returns common boxed Errno values, to prevent
//// allocations at runtime.
//func errnoErr(e syscall.Errno) error {
//    switch e {
//    case 0:
//        return nil
//    case syscall.EAGAIN:
//        return  syscall.EAGAIN
//    case syscall.EINVAL:
//        return syscall.EINVAL
//    case syscall.ENOENT:
//        return syscall.ENOENT
//    }
//    return e
//}
//
////go:linkname rawSyscall runtime.rawSyscall
//func rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
//
//// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//
//func fork() (pid int, err error) {
//    r0, _, e1 := rawSyscall(funcPC(libc_fork_trampoline), 0, 0, 0)
//    pid = int(r0)
//    if e1 != 0 {
//        err = errnoErr(e1)
//    }
//    return
//}
//
//func libc_fork_trampoline()
//
////go:linkname libc_fork libc_fork
////go:cgo_import_dynamic libc_fork fork "/usr/lib/libSystem.B.dylib"
//
//
//// Find the entry point for f. See comments in runtime/proc.go for the
//// function of the same name.
////go:nosplit
//func funcPC(f func()) uintptr {
//    return **(**uintptr)(unsafe.Pointer(&f))
//}


func main() {
    exeArgs := &syscall.ProcAttr{
       Env:   os.Environ(),
       Files: []uintptr { os.Stdin.Fd(),  os.Stdout.Fd(),  os.Stderr.Fd()  },
       Sys:   nil,
    }
    pid, err := forkexec.ForkExec("./test", nil, exeArgs)
    if err != nil {
       panic(err)
    }
    fmt.Println(pid)
    if pid > 0 {
       time.Sleep(time.Second)
    }
}