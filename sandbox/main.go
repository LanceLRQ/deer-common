package main

import (
    "fmt"
    "github.com/LanceLRQ/deer-common/sandbox/process"
    "os"
)

//
//import (
//    "C"
//    "syscall"
//    "unsafe"
//    _ "unsafe"
//)
//
//// errnoErr returns common boxed Errno values, to prevent
//// allocations at runtime.
//func errnoErr(e syscall.Errno) error {
//    switch e {
//    case 0:
//        return nil
//    case syscall.EAGAIN:
//        return  syscall.EAGAIN
//    case syscall.EINVAL:
//        return syscall.EINVAL
//    case syscall.ENOENT:
//        return syscall.ENOENT
//    }
//    return e
//}
//
////go:linkname rawSyscall runtime.rawSyscall
//func rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
//
//// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
//
//func fork() (pid int, err error) {
//    r0, _, e1 := rawSyscall(funcPC(libc_fork_trampoline), 0, 0, 0)
//    pid = int(r0)
//    if e1 != 0 {
//        err = errnoErr(e1)
//    }
//    return
//}
//
//func libc_fork_trampoline()
//
////go:linkname libc_fork libc_fork
////go:cgo_import_dynamic libc_fork fork "/usr/lib/libSystem.B.dylib"
//
//
//// Find the entry point for f. See comments in runtime/proc.go for the
//// function of the same name.
////go:nosplit
//func funcPC(f func()) uintptr {
//    return **(**uintptr)(unsafe.Pointer(&f))
//}

func test() {
    p, err := process.StartProcess("./test", nil, &process.ProcAttr{
        Env:   os.Environ(),
        Files: []*os.File { os.Stdin,  os.Stdout,  os.Stderr  },
    })
    if err != nil {
        panic(err)
    }
    ps, err := p.Wait()
    if err != nil {
        panic(err)
    }
    fmt.Printf("\n\nExitCode: %d\n", ps.ExitCode())
}

func main() {
    //for i := 0; i < 1000; i++ {
    //   go test(i)
    //}
    test()
    //fmt.Println("AA")
    //time.Sleep(100 * time.Second)
}